description: OpenSiv3D v0.4.1 ã®æ–°æ©Ÿèƒ½ã®è§£èª¬ã¨ã‚µãƒ³ãƒ—ãƒ«

## 1. ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
ã“ã‚Œã¾ã§ã€å›³å½¢ã‚„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¯ã‚·ãƒ¼ãƒ³ã«ã—ã‹æç”»ã§ãã¾ã›ã‚“ã§ã—ãŸãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ç”¨æ„ã—ãŸåˆ¥ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚‚æç”»ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚`RenderTexture` ã‚’ä½œæˆã—ã€`ScopedRenderTarget2D` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ¸¡ã™ã¨ã€`ScopedRenderTarget2D` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—ãŒæœ‰åŠ¹ãªé–“ã€å›³å½¢ã‚„ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«æç”»ã•ã‚Œã¾ã™ï¼ˆãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å¤‰æ›´ï¼‰ã€‚æç”»ã•ã‚ŒãŸãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¯ã€ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰è§£é™¤ã•ã‚ŒãŸã‚ã¨ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦æç”»ã«è»¢ç”¨ã§ãã¾ã™ã€‚

!!! warning
    ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦è¨­å®šã•ã‚Œã¦ã„ã‚‹æœ€ä¸­ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã€æç”»ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/1.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	// ã‚·ãƒ¼ãƒ³ã®èƒŒæ™¯è‰²ã‚’æ·¡ã„æ°´è‰²ã«è¨­å®š
	Scene::SetBackground(ColorF(0.8, 0.9, 1.0));
	
	// çµµæ–‡å­—
	const Texture emoji(Emoji(U"ğŸ˜‡"));

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	RenderTexture rt(600, 600, Palette::White);

	while (System::Update())
	{
		// ãƒã‚¦ã‚¹ã®å·¦ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ãŸã‚‰
		if (MouseL.pressed())
		{
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ rt ã«è¨­å®š
			ScopedRenderTarget2D target(rt);
			emoji.drawAt(Cursor::Pos());
		}

		rt.draw();
		emoji.drawAt(Cursor::Pos());

		// Clear ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰
		if (SimpleGUI::Button(U"Clear", Vec2(650, 20)))
		{
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç™½ã§ã‚¯ãƒªã‚¢
			rt.clear(Palette::White);
		}
	}
}
```


## 2. ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
é€šå¸¸ã® `RenderTexture` ã¸ã®æç”»ã§ã¯ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ»ã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚·ãƒ³ã‚°ãŒæœ‰åŠ¹ã«ãªã‚‰ãªã„ã®ã§ã€å›³å½¢ã‚’æç”»ã—ãŸéš›ã«ã‚¸ãƒ£ã‚®ãƒ¼ãŒç”Ÿã˜ã¾ã™ã€‚`MSRenderTexture` ã‚’ä½¿ã†ã¨ã€é€šå¸¸ã®ã‚·ãƒ¼ãƒ³ã¸ã®æç”»ã¨åŒã˜ã‚ˆã†ã«ã€ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ»ã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚·ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã—ã¦æç”»ã§ãã¾ã™ã€‚ãŸã ã—ã€`MSRenderTexture` ã«æç”»ã•ã‚ŒãŸçµæœã‚’ã€åˆ¥ã®æç”»ã§ä½¿ã†éš›ã«ã¯ã€`Graphics2D::Flush()` ã«ã‚ˆã£ã¦ãã®æ™‚ç‚¹ã¾ã§ã®æç”»å‡¦ç†ã‚’ã™ã¹ã¦å®Ÿè¡Œï¼ˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‰ã—ã¦ `MSRenderTexture` ã«ç¢ºå®Ÿã«æç”»ã—ãŸã‚ã¨ã«ã€`MSRenderTexture::resolve()` ã‚’è¡Œã„ã€`MSRenderTexture` å†…ã®ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã€æç”»ã§ä½¿ç”¨å¯èƒ½ãªé€šå¸¸ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«å¤‰æ›ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/2.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.8, 0.9, 1.0));

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	RenderTexture rt(200, 200);

	// ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	MSRenderTexture msrt(200, 200);

	while (System::Update())
	{
		rt.clear(ColorF(0.0, 1.0));
		{
			ScopedRenderTarget2D target(rt);

			Rect(Arg::center(100, 100), 80)
				.rotated(Scene::Time() * 30_deg).draw();
		}

		msrt.clear(ColorF(0.0, 1.0));
		{
			{
				ScopedRenderTarget2D target(msrt);

				Rect(Arg::center(100, 100), 80)
					.rotated(Scene::Time() * 30_deg).draw();
			}

			// 2D æç”»ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
			Graphics2D::Flush();

			// ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æç”»å¯èƒ½ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã«å¤‰æ›
			msrt.resolve();
		}

		rt.draw(100, 0);
	
		msrt.draw(400, 0);
	}
}
```

## 3. ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã®ã‚·ã‚§ãƒ¼ãƒ€å‡¦ç†
ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã‚‰åˆ¥ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã®æ§˜ã€…ãªå¤‰æ›å‡¦ç†ã‚’é–¢æ•° 1 ã¤ã§å®Ÿè¡Œã§ãã¾ã™ã€‚ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆã®å¤‰æ›´ã‚‚ä¸è¦ã§ã™ã€‚æä¾›ã•ã‚Œã‚‹é–¢æ•°ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚

#### `void Copy(const TextureRegion& from, RenderTexture& to);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã‚’ `to` ã«æç”»ã—ã¾ã™ã€‚`from` ã¨ `to` ã¯ã¨ã‚‚ã«æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€äº’ã„ã«ç•°ãªã‚Šã€é ˜åŸŸã®ã‚µã‚¤ã‚ºãŒåŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

#### `void Downsample(const TextureRegion& from, RenderTexture& to);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã‚’ç¸®å°ã—ã¦ `to` ã«æç”»ã—ã¾ã™ã€‚`from` ã¨ `to` ã¯ã¨ã‚‚ã«æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€äº’ã„ã«ç•°ãªã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

#### `void GaussianBlurH(const TextureRegion& from, RenderTexture& to);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã«æ¨ªæ–¹å‘ã®ã‚¬ã‚¦ã‚¹ãƒ–ãƒ©ãƒ¼ã‚’ã‹ã‘ã¦ `to` ã«æç”»ã—ã¾ã™ã€‚`from` ã¨ `to` ã¯ã¨ã‚‚ã«æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€äº’ã„ã«ç•°ãªã‚Šã€é ˜åŸŸã®ã‚µã‚¤ã‚ºãŒåŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

#### `void GaussianBlurV(const TextureRegion& from, RenderTexture& to);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã«ç¸¦æ–¹å‘ã®ã‚¬ã‚¦ã‚¹ãƒ–ãƒ©ãƒ¼ã‚’ã‹ã‘ã¦ `to` ã«æç”»ã—ã¾ã™ã€‚`from` ã¨ `to` ã¯ã¨ã‚‚ã«æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€äº’ã„ã«ç•°ãªã‚Šã€é ˜åŸŸã®ã‚µã‚¤ã‚ºãŒåŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

#### `void GaussianBlur(const TextureRegion& from, RenderTexture& to, const Vec2& direction);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- direction: ãƒ–ãƒ©ãƒ¼ã®æ–¹å‘

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã«æŒ‡å®šã—ãŸæ–¹å‘ã®ã‚¬ã‚¦ã‚¹ãƒ–ãƒ©ãƒ¼ã‚’ã‹ã‘ã¦ `to` ã«æç”»ã—ã¾ã™ã€‚`from` ã¨ `to` ã¯ã¨ã‚‚ã«æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€äº’ã„ã«ç•°ãªã‚Šã€é ˜åŸŸã®ã‚µã‚¤ã‚ºãŒåŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

#### `void GaussianBlur(const TextureRegion& from, RenderTexture& internalBuffer, RenderTexture& to);`
- from: å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
- internalBuffer: ä¸­é–“ãƒ†ã‚¯ã‚¹ãƒãƒ£
- to: å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£

`from` ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å†…å®¹ã‚’ã«ç¸¦æ–¹å‘ã¨æ¨ªæ–¹å‘ã®ã‚¬ã‚¦ã‚¹ãƒ–ãƒ©ãƒ¼ã‚’ã‹ã‘ã¦ `to` ã«æç”»ã—ã¾ã™ã€‚`from`, `internalBuffer`, `to` ã¯ã„ãšã‚Œã‚‚æœ‰åŠ¹ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã§ã€éš£ã‚Šåˆã†ã‚‚ã®åŒå£«ã¯ç•°ãªã‚Šã€é ˜åŸŸã®ã‚µã‚¤ã‚ºãŒåŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚  
`GaussianBlurH(from, internalBuffer); GaussianBlurV(internalBuffer, to);` ã¨ç­‰ä¾¡ã§ã™ã€‚

### ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/3.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture texture(U"example/windmill.png");

	// ç¸¦ã€æ¨ªãŒ 4 åˆ†ã® 1 ã‚µã‚¤ã‚ºã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	RenderTexture rt(texture.size() / 4);

	// ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
	Shader::Downsample(texture, rt);

	while (System::Update())
	{
		rt.draw();
	}
}
```

#### ã‚¬ã‚¦ã‚¹ã¼ã‹ã—

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/4.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ 1280x720 ã«ãƒªã‚µã‚¤ã‚º
	Window::Resize(1280, 720);

	// bay.jpg ã¯ 2560x1440 ãªã®ã§ã‚µã‚¤ã‚ºã‚’å°ã•ãã—ã¦ãƒ­ãƒ¼ãƒ‰
	const Texture texture(Image(U"example/bay.jpg").scale(1280, 720));

	// ã¼ã‹ã—ã‚’é©ç”¨ã™ã‚‹é ˜åŸŸã®ã‚µã‚¤ã‚º
	constexpr Size blurAreaSize(480, 320);

	// ã‚¬ã‚¦ã‚¹ã¼ã‹ã—ã®ä¸­é–“ã§ä½¿ã†ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç”¨æ„
	RenderTexture rtA(blurAreaSize), rtB(blurAreaSize);
	RenderTexture rtA4(blurAreaSize / 4), rtB4(blurAreaSize / 4);
	RenderTexture rtA8(blurAreaSize / 8), rtB8(blurAreaSize / 8);

	while (System::Update())
	{
		const Point cursorPos = Cursor::Pos();

		// èƒŒæ™¯ç”»åƒã®ã†ã¡ã¼ã‹ã—ã‚’é©ç”¨ã™ã‚‹é ˜åŸŸ
		const Rect blurArea(cursorPos, blurAreaSize);

		// [ã‚ªãƒªã‚¸ãƒŠãƒ«]->[ã‚¬ã‚¦ã‚¹ã¼ã‹ã—]->[1/4ã‚µã‚¤ã‚º]->[ã‚¬ã‚¦ã‚¹ã¼ã‹ã—]->[1/8ã‚µã‚¤ã‚º]->[ã‚¬ã‚¦ã‚¹ã¼ã‹ã—]
		Shader::GaussianBlur(texture(blurArea), rtB, rtA);
		Shader::Downsample(rtA, rtA4);
		Shader::GaussianBlur(rtA4, rtB4, rtA4);
		Shader::Downsample(rtA4, rtA8);
		Shader::GaussianBlur(rtA8, rtB8, rtA8);

		// èƒŒæ™¯ã‚’æç”»
		texture.draw();

		// ã‚¬ã‚¦ã‚¹ã¼ã‹ã—å¾Œã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ RoundRect ã«è²¼ã‚Šä»˜ã‘ã¦æç”»
		RoundRect(cursorPos, blurAreaSize, 40)(rtA8.resized(blurAreaSize)).draw();
	}
}
```


## 4. ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
2D ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚„å›³å½¢ãŒãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«æã‹ã‚Œã‚‹ã¨ãã€ã©ã®ã‚ˆã†ãªè‰²ã‚’å‡ºåŠ›ã™ã‚‹ã‹ã¯ã€ã€Œãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§â€•ãƒ€ã€ã¨å‘¼ã°ã‚Œã‚‹ã€ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ã« GPU ä¸Šã§å®Ÿè¡Œã•ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é€šã—ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ Windows (Direct3D) ã§ã¯ã€ŒHLSLã€ã€macOS/Linux (OpenGL) ã§ã¯ã€ŒGLSLã€ã¨ã„ã†è¨€èªã§è¨˜è¿°ã—ã¾ã™ã€‚ã‚«ã‚¹ã‚¿ãƒ ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãå‰ã«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã©ã®ã‚ˆã†ãªã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§å›³å½¢ã‚„ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæã‹ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### å›³å½¢ã‚’æãã¨ãã«ä½¿ã‚ã‚Œã‚‹åŸºæœ¬ã‚·ã‚§ãƒ¼ãƒ€

#### HLSL
`PS()` é–¢æ•°ãŒãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã§ã™ã€‚é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®å‡ºåŠ›ã§ã‚ã‚‹ `PSInput` å‹ã®å€¤ `input` ã® `.position`, `.color`, `.uv` ãƒ¡ãƒ³ãƒå¤‰æ•°ã®ã†ã¡ `.color` ã¨å®šæ•°ãƒãƒƒãƒ•ã‚¡ `g_colorAdd` ã ã‘ã‚’ä½¿ã£ã¦ã€å‡ºåŠ›ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã® RGBA è‰² (float4 å‹) ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚

`Rect(100).draw(ColorF(0.3, 0.5, 0.7))` ã®ã‚ˆã†ã«æç”»ã—ãŸã¨ãã€`input.color` ãŒ `float4(0.3, 0.5, 0.7, 1.0)` ã§ã™ã€‚ãªãŠã€`ScopedColorMul2D` ã‚’å¤‰æ›´ã—ãŸå ´åˆã«ã¯ãã®å€¤ãŒä¹—ç®—æ¸ˆã¿ã§æ¸¡ã•ã‚Œã¾ã™ã€‚ `g_colorAdd` ã¯ `ScopedAdd2D` ã§æŒ‡å®šã—ãŸå€¤ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¦ã€åŸºæœ¬çš„ã«ã¯ `flaot4(0.0, 0.0, 0.0, 0.0)` ã§ã™ã€‚

ã—ãŸãŒã£ã¦ã€ã“ã®åŸºæœ¬ã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½¿ã†ã¨ã€`.draw()` ã§æŒ‡å®šã—ãŸè‰² Ã— `ColorMul2D` + `ColorAdd2D` ã®è‰²ã§å›³å½¢ãŒç”»é¢ã«æã‹ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã—ãŸè¨ˆç®—ã‚’ã›ãšã« `return float4(1, 0, 0, 1)` ã‚’è¿”ã›ã°ã€å›³å½¢ã¯èµ¤ãæç”»ã•ã‚Œã¾ã™ã€‚

- engine/shader/2d/default_shape.hlsl

```C++
Texture2D		g_texture0 : register(t0);
SamplerState	g_sampler0 : register(s0);

cbuffer PSConstants2D : register(b0)
{
	float4 g_colorAdd;
	float4 g_sdfParam;
	float4 g_internal;
}

struct PSInput
{
	float4 position	: SV_POSITION;
	float4 color	: COLOR0;
	float2 uv		: TEXCOORD0;
};

float4 PS(PSInput input) : SV_TARGET
{
	return input.color + g_colorAdd;
}
```

#### GLSL
`main()` é–¢æ•°ãŒãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã§ã™ã€‚é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®å‡ºåŠ›ã§ã‚ã‚‹ `vec4` å‹ã®å€¤ `Color` ã¨å®šæ•°ãƒãƒƒãƒ•ã‚¡ `g_colorAdd` ã ã‘ã‚’ä½¿ã£ã¦ã€å‡ºåŠ›ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã® RGBA è‰² (float4 å‹) ã‚’è¨ˆç®—ã—ã€`FragColor` ã«æ ¼ç´ã—ã¦ã„ã¾ã™ã€‚

`Rect(100).draw(ColorF(0.3, 0.5, 0.7))` ã®ã‚ˆã†ã«æç”»ã—ãŸã¨ãã€`Color` ãŒ `vec4(0.3, 0.5, 0.7, 1.0)` ã§ã™ã€‚ãªãŠã€`ScopedColorMul2D` ã‚’å¤‰æ›´ã—ãŸå ´åˆã«ã¯ãã®å€¤ãŒä¹—ç®—æ¸ˆã¿ã§æ¸¡ã•ã‚Œã¾ã™ã€‚ `g_colorAdd` ã¯ `ScopedAdd2D` ã§æŒ‡å®šã—ãŸå€¤ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¦ã€åŸºæœ¬çš„ã«ã¯ `vec4(0.0, 0.0, 0.0, 0.0)` ã§ã™ã€‚

ã—ãŸãŒã£ã¦ã€ã“ã®åŸºæœ¬ã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½¿ã†ã¨ã€`.draw()` ã§æŒ‡å®šã—ãŸè‰² Ã— `ColorMul2D` + `ColorAdd2D` ã®è‰²ã§å›³å½¢ãŒç”»é¢ã«æã‹ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã—ãŸè¨ˆç®—ã‚’ã›ãšã« `FragColor = vec4(1, 0, 0, 1)` ã¨ã™ã‚Œã°ã€å›³å½¢ã¯èµ¤ãæç”»ã•ã‚Œã¾ã™ã€‚

- engine/shader/2d/default_shape.frag

```C++
#version 410

layout(std140) uniform PSConstants2D
{
	vec4 g_colorAdd;
	vec4 g_sdfParam;
	vec4 g_internal;	
};

//
// PSInput
//
layout(location = 0) in vec4 Color;

//
// PSOutput
//
layout(location = 0) out vec4 FragColor;
		
void main()
{
	FragColor = Color + g_colorAdd;
}
```


### ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æãã¨ãã«ä½¿ã‚ã‚Œã‚‹åŸºæœ¬ã‚·ã‚§ãƒ¼ãƒ€

#### HLSL
åŸºæœ¬çš„ãªæµã‚Œã¯å›³å½¢ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨åŒã˜ã§ã™ãŒã€è¿½åŠ ã§ãƒ†ã‚¯ã‚¹ãƒãƒ£ `g_texture0` ã¨ã‚µãƒ³ãƒ—ãƒ©ãƒ¼ `g_sampler0` ã‚’ä½¿ã£ã¦ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã‚‰è‰²ã‚’å–å¾—ã—ã¾ã™ã€‚UV åº§æ¨™ã¨ã—ã¦é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰æ¸¡ã•ã‚Œã‚‹ `input.uv` ã‚’ä½¿ã„ã¾ã™ã€‚

- engine/shader/2d/default_texture.hlsl

```C++
Texture2D		g_texture0 : register(t0);
SamplerState	g_sampler0 : register(s0);

cbuffer PSConstants2D : register(b0)
{
	float4 g_colorAdd;
	float4 g_sdfParam;
	float4 g_internal;
}

struct PSInput
{
	float4 position	: SV_POSITION;
	float4 color	: COLOR0;
	float2 uv		: TEXCOORD0;
};

float4 PS(PSInput input) : SV_TARGET
{
	float4 texColor = g_texture0.Sample(g_sampler0, input.uv);

	return (texColor * input.color) + g_colorAdd;
}
```


#### GLSL

åŸºæœ¬çš„ãªæµã‚Œã¯å›³å½¢ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨åŒã˜ã§ã™ãŒã€è¿½åŠ ã§ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µãƒ³ãƒ—ãƒ©ãƒ¼  `Texture0` ã‹ã‚‰è‰²ã‚’å–å¾—ã—ã¦ã„ã¾ã™ã€‚UV åº§æ¨™ã¨ã—ã¦é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰æ¸¡ã•ã‚Œã‚‹å€¤ `UV` ã‚’ä½¿ã„ã¾ã™ã€‚

- engine/shader/2d/default_texture.frag

```C++
#version 410

uniform sampler2D Texture0;

layout(std140) uniform PSConstants2D
{
	vec4 g_colorAdd;
	vec4 g_sdfParam;
	vec4 g_internal;	
};

//
// PSInput
//
layout(location = 0) in vec4 Color;
layout(location = 1) in vec2 UV;
		
//
// PSOutput
//
layout(location = 0) out vec4 FragColor;
		
void main()
{
	vec4 texColor = texture(Texture0, UV);

	FragColor = (texColor * Color) + g_colorAdd;
}
```

### ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®ä½¿ç”¨
ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’èª­ã¿è¾¼ã‚€ã«ã¯ `PixelShader` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã„ã¾ã™ã€‚`PixelShader` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼•æ•°ã«ã€èª­ã¿è¾¼ã¿ãŸã„ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’æ¸¡ã—ã¾ã™ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¯ã€å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ãƒ•ã‚©ãƒ«ãƒ€ï¼ˆé–‹ç™ºä¸­ã¯ App ãƒ•ã‚©ãƒ«ãƒ€ï¼‰ã‚’åŸºæº–ã¨ã™ã‚‹ç›¸å¯¾ãƒ‘ã‚¹ã‹ã€çµ¶å¯¾ãƒ‘ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒªãƒªãƒ¼ã‚¹ç”¨ã®ã‚¢ãƒ—ãƒªã‚’ä½œã‚‹ã¨ãã«ã¯ã€ã®ã¡ã®ç« ã§èª¬æ˜ã™ã‚‹ã€Œãƒªã‚½ãƒ¼ã‚¹ã€ãƒ‘ã‚¹ã®ä½¿ç”¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ é–‹ç™ºã§ã¯ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’ä½¿ã„åˆ†ã‘ã‚‹ãŸã‚ã« `SIV3D_SELECT_SHADER` ãƒã‚¯ãƒ­ã‚’ä½¿ã„ã¾ã™ã€‚
`PixelShader` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ç¬¬äºŒå¼•æ•°ã«ã¯ã€å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å¯¾å¿œä»˜ã‘ã®ãŸã‚ã« `{ { U"PSConstants2D", 0 } }` ã‚’è¨˜è¿°ã—ã¾ã™ã€‚2D æç”»ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã«ãŠã„ã¦ã¯ã€Siv3D å†…éƒ¨ã®å‡¦ç†ã®ãŸã‚ã«ã€`U"PSConstants2D"` ã¨ã„ã†åå‰ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 0 ã«å¸¸ã«è¨­å®šã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸã‹ã©ã†ã‹ã¯ if (!ps) ã§èª¿ã¹ã‚‰ã‚Œã¾ã™ã€‚

`ScopedCustomShader2D` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã€ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’æ¸¡ã™ã¨ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—ãŒæœ‰åŠ¹ãªé–“ã€å›³å½¢ã‚„ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãã®ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã«ã‚ˆã£ã¦æç”»ã•ã‚Œã¾ã™ã€‚æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã® R æˆåˆ†ã¨ B æˆåˆ†ã‚’å…¥ã‚Œæ›¿ãˆã¦æç”»ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/5.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// R ã¨ B ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/rgb_to_bgr" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		{
			// R ã¨ B ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```

### ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã‚·ã‚§ãƒ¼ãƒ€ã®ä½¿ç”¨ (Windows ã®ã¿)
`Platform::Windows::Shader::CompileHLSLToFile()` é–¢æ•°ã‚’ä½¿ã†ã¨ã€HLSL ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚ã‚‰ã‹ã˜ã‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ãŠãã“ã¨ãŒã§ãã€å®Ÿè¡Œæ™‚ã®å‡¦ç†ã‚’å‰Šæ¸›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã®ã‚·ã‚§ãƒ¼ãƒ€ã¯ `PixelShader` ã§ãã®ã¾ã¾èª­ã¿è¾¼ã‚ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªãƒªãƒ¼ã‚¹ã™ã‚‹ã¨ãã«ã¯ã€å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã«ã—ã¦ãŠãã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture windmill(U"example/windmill.png");

# if SIV3D_PLATFORM(WINDOWS)

	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½œã£ã¦ä¿å­˜ã™ã‚‹ï¼ˆ1 åº¦ã ã‘ä½œæˆã™ã‚Œã° OKï¼‰
	//Platform::Windows::Shader::CompileHLSLToFile(
	//	U"example/shader/2d/rgb_to_bgr.hlsl",
	//	U"example/shader/2d/rgb_to_bgr.ps",
	//	ShaderStage::Pixel, U"PS");

# endif

	// R ã¨ B ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ ps, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/rgb_to_bgr" SIV3D_SELECT_SHADER(U".ps", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		{
			// R ã¨ B ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```

### ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®ã‚µãƒ³ãƒ—ãƒ« 

#### RGB ã‚·ãƒ•ãƒˆ

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/6.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// RGB ã‚·ãƒ•ãƒˆç”¨ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/rgb_shift" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		{
			// RGB ã‚·ãƒ•ãƒˆç”¨ã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```


#### ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/7.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/grayscale" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		{
			// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```


#### ãƒã‚¹ã‚¿ãƒ©ã‚¤ã‚º

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/8.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// ãƒã‚¹ã‚¿ãƒ©ã‚¤ã‚ºåŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/posterize" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		{
			// ãƒã‚¹ã‚¿ãƒ©ã‚¤ã‚ºåŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```


#### Poisson-Disk Sampling
å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã†ã¨ã€C++ ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å€¤ã‚’æ¸¡ã›ã¾ã™ã€‚å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«ã™ã‚‹æ§‹é€ ä½“ã¯ 16 ã®å€æ•°ã®ã‚µã‚¤ã‚ºã§ç”¨æ„ã—ã¾ã™ã€‚1 ã¤ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®æœ€å¤§ã‚µã‚¤ã‚ºã¯ 64KB ã§ã™ã€‚

ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã§æ–°ã—ã„å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã†ã«ã¯ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¿½åŠ ã—ã€`PixelShader` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ç¬¬äºŒå¼•æ•°ã«ã€å¯¾å¿œã™ã‚‹è¿½åŠ ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ ã—ã¾ã™ã€‚ãªãŠã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å­˜åœ¨ã™ã‚‹ `PSConstants2D` å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

C++ ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€`ConstantBuffer<>` ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«ã™ã‚‹æ§‹é€ ä½“ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ä½œã‚Šã€ã“ã®ã‚¯ãƒ©ã‚¹çµŒç”±ã§å€¤ã‚’æ“ä½œã—ã¾ã™ã€‚æç”»å‰ã«ã€`Graphics2D::SetConstantBuffer()` ã«ã‚ˆã£ã¦ã€é©åˆ‡ãªå®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ã—ã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/9.png?raw=true)

```C++
# include <Siv3D.hpp>

// å®šæ•°ãƒãƒƒãƒ•ã‚¡ (PS_1)
struct PoissonDisk
{
	// 1 ãƒ”ã‚¯ã‚»ãƒ«ã‚ãŸã‚Šã® UV ã‚µã‚¤ã‚º
	Float2 pixelSize;

	// ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°åŠå¾„
	float diskRadius;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’
	// 16 ã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
	float _unused = 0.0f;
};

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// Poisson-Disk Sampling ç”¨ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/poisson_disk" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 }, { U"PoissonDisk", 1 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ConstantBuffer<PoissonDisk> cb;
	cb->pixelSize = Float2(1.0, 1.0) / windmill.size();

	// ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°åŠå¾„
	double diskRadius = 0.0;

	while (System::Update())
	{
		// ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°åŠå¾„ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§å¤‰æ›´
		SimpleGUI::Slider(U"diskRadius", diskRadius, 0.0, 8.0, Vec2(10, 340), 120, 200);

		cb->diskRadius = static_cast<float>(diskRadius);

		{
			// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’ã€ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 1 ã«è¨­å®š
			Graphics2D::SetConstantBuffer(ShaderStage::Pixel, 1, cb);

			// Poisson-Disk Sampling ç”¨ã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```


#### æ¸¦å·»ãåŠ¹æœ

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/10.png?raw=true)

```C++
# include <Siv3D.hpp>

// å®šæ•°ãƒãƒƒãƒ•ã‚¡ (PS_1)
struct Swirl
{
	// å›è»¢
	float angle;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’
	// 16 ã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
	Float3 unused = {};
};

void Main()
{
	const Texture windmill(U"example/windmill.png");

	// æ¸¦å·»ãåŠ¹æœã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/swirl" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 }, { U"Swirl", 1 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ConstantBuffer<Swirl> cb;

	while (System::Update())
	{
		cb->angle = static_cast<float>(Math::Sin(Scene::Time()) * 720_deg);

		{
			// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
			Graphics2D::SetConstantBuffer(ShaderStage::Pixel, 1, cb);

			// æ¸¦å·»ãåŠ¹æœã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(10, 10);
		}
	}
}
```


#### ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
é€šå¸¸ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£æç”»ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€æç”»ã§ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 0 ã«ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚`Graphics2D::SetTexture()` ã‚’ä½¿ã†ã¨ã€ãã‚Œä»¥å¤–ã®ã‚¹ãƒ­ãƒƒãƒˆã«è¿½åŠ ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚»ãƒƒãƒˆã—ã¦ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§è¤‡æ•°ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚`Graphics2D::SetTexture()` ã« `none` ã‚’æ¸¡ã™ã“ã¨ã§ã‚¹ãƒ­ãƒƒãƒˆã«ã‚»ãƒƒãƒˆã—ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è§£é™¤ã§ãã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/11.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	const Texture emojiCat(Emoji(U"ğŸˆ"));

	const Texture windmill(U"example/windmill.png", TextureDesc::Mipped);

	// ãƒãƒ«ãƒãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚ˆã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/multi_texture_blend" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });
		
	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	while (System::Update())
	{
		// windmill ã‚’ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ [1] ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¹ãƒ­ãƒƒãƒˆã«ã‚»ãƒƒãƒˆ 
		Graphics2D::SetTexture(1, windmill);
		{
			// ãƒãƒ«ãƒãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚ˆã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			emojiCat.scaled(2).drawAt(Scene::Center());
		}
	}
}
```


#### ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒã‚¹ã‚¯

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/12.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ 960x600 ã«ãƒªã‚µã‚¤ã‚º
	Window::Resize(960, 600);

	// ã‚·ãƒ¼ãƒ³ã®èƒŒæ™¯è‰²ã‚’æ·¡ã„æ°´è‰²ã«è¨­å®š
	Scene::SetBackground(ColorF(0.8, 0.9, 1.0));

	// ãƒãƒ«ãƒãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚ˆã‚‹ãƒã‚¹ã‚¯ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/multi_texture_mask" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });

	if (!ps)
	{
		throw Error(U"Failed to load a shader file");
	}

	// çµµæ–‡å­—ã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆç”»åƒ
	const Texture emoji(Emoji::CreateSilhouetteImage(U"ğŸ"), TextureDesc::Mipped);

	// é¢¨è»Šã®å†™çœŸ
	const Texture windmill(U"example/windmill.png");

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
	RenderTexture rt(480, 320);

	while (System::Update())
	{
		// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚¯ãƒªã‚¢
		rt.clear(ColorF(0.0, 1.0));
		{
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ rt ã«è¨­å®š
			ScopedRenderTarget2D target(rt);
			emoji.scaled(2).rotated(Scene::Time() * 60_deg).drawAt(rt.size() / 2);
		}

		// æç”»ã•ã‚ŒãŸ rt ã‚’è¡¨ç¤º
		rt.draw(0, 140);

		// rt ã‚’ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ [1] ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¹ãƒ­ãƒƒãƒˆã«ã‚»ãƒƒãƒˆ 
		Graphics2D::SetTexture(1, rt);
		{
			// ãƒãƒ«ãƒãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚ˆã‚‹ãƒã‚¹ã‚¯ã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(ps);
			windmill.draw(480, 140);
		}
	}
}
```


#### GPU ä¸Šã§ã®ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã§å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/13.png?raw=true)

```C++
# include <Siv3D.hpp>

// å®šæ•°ãƒãƒƒãƒ•ã‚¡ (PS_1)
struct GameOfLife
{
	Float2 pixelSize;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’
	// 16 ã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°	
	Float2 _unused = {};
};

void Main()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ 1280x720 ã«ãƒªã‚µã‚¤ã‚º
	Window::Resize(1280, 720);

	// ã‚»ãƒ«ã®æ•° (1280x720)
	constexpr Size FieldSize(1280, 720);

	// ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ç”¨ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/game_of_life" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 }, { U"GameOfLife", 1 } });

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	const ConstantBuffer<GameOfLife> cb({ Float2(1.0f, 1.0f) / FieldSize });

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ 0
	RenderTexture rt0(Image(FieldSize, Arg::generator = []() { return Color(RandomBool() * 255); }));

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ 1
	RenderTexture rt1(FieldSize, ColorF(0.0));

	while (System::Update())
	{
		{
			// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚£ãƒ«ã‚¿ãªã—
			ScopedRenderStates2D sampler(SamplerState::ClampNearest);

			// ç¾åœ¨ã®çŠ¶æ…‹ã‚’ç”»é¢ã«æã
			rt0.draw(ColorF(0.0, 1.0, 0.0));

			{
				// ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ç”¨ã®ã‚·ã‚§ãƒ¼ãƒ€
				Graphics2D::SetConstantBuffer(ShaderStage::Pixel, 1, cb);
				ScopedCustomShader2D shader(ps);

				// æ›´æ–°å¾Œã®çŠ¶æ…‹ã‚’æã rt1 ã«æã
				ScopedRenderTarget2D target(rt1);
				rt0.draw();
			}
		}

		// rt0 ã¨ rt1 ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
		std::swap(rt0, rt1);
	}
}
```

#### GPU ä¸Šã§ã®ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ2D ã‚«ãƒ¡ãƒ©æ“ä½œå¯¾å¿œç‰ˆï¼‰
ãƒã‚¦ã‚¹ã‚„ã‚­ãƒ¼ã‚’ä½¿ã£ãŸ 2D ã‚«ãƒ¡ãƒ©æ“ä½œã§æ‹¡å¤§ç¸®å°ã‚„ç§»å‹•ãŒã§ãã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/14.png?raw=true)

```C++
# include <Siv3D.hpp>

// å®šæ•°ãƒãƒƒãƒ•ã‚¡ (PS_1)
struct GameOfLife
{
	Float2 pixelSize;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’
	// 16 ã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
	Float2 _unused = {};
};

void Main()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ 1280x720 ã«ãƒªã‚µã‚¤ã‚º
	Window::Resize(1280, 720);

	// ã‚·ãƒ¼ãƒ³ã®èƒŒæ™¯è‰²ã‚’ã‚°ãƒ¬ãƒ¼ã«è¨­å®š
	Scene::SetBackground(ColorF(0.5));

	// ã‚»ãƒ«ã®æ•° (2048x2048), æœ€å¤§ (8192x8192)
	constexpr Size FieldSize(2048, 2048);

	// ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ç”¨ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader ps(U"example/shader/2d/game_of_life" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 }, { U"GameOfLife", 1 } });

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	const ConstantBuffer<GameOfLife> cb({ Float2(1.0f, 1.0f) / FieldSize });

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ 0
	RenderTexture rt0(Image(FieldSize, Arg::generator = []() { return Color(RandomBool() * 255); }));

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ 1
	RenderTexture rt1(FieldSize, ColorF(0.0));

	// 2D ã‚«ãƒ¡ãƒ©
	Camera2D camera(Vec2(0, 0), 4);

	while (System::Update())
	{
		// 2D ã‚«ãƒ¡ãƒ©ã‚’æ›´æ–°
		camera.update();
		{
			// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚£ãƒ«ã‚¿ãªã—
			ScopedRenderStates2D sampler(SamplerState::ClampNearest);

			{
				// 2D ã‚«ãƒ¡ãƒ©ã®è¨­å®šã‹ã‚‰ Transformer2D ã‚’ä½œæˆ
				const auto t = camera.createTransformer();

				// ç¾åœ¨ã®çŠ¶æ…‹ã‚’ç”»é¢ã«æã
				rt0.draw(ColorF(0.0, 1.0, 0.0));

				// 2D ã‚«ãƒ¡ãƒ©ã® UI ã‚’æç”»
				camera.draw(Palette::Orange);
			}

			{
				// ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ç”¨ã®ã‚·ã‚§ãƒ¼ãƒ€
				Graphics2D::SetConstantBuffer(ShaderStage::Pixel, 1, cb);
				ScopedCustomShader2D shader(ps);

				// æ›´æ–°å¾Œã®çŠ¶æ…‹ã‚’æã rt1 ã«æã
				ScopedRenderTarget2D target(rt1);
				rt0.draw();
			}
		}

		// rt0 ã¨ rt1 ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
		std::swap(rt0, rt1);
	}
}
```


#### ã‚²ãƒ¼ãƒ ç”»é¢ã«å¾Œå‡¦ç†ã¨ã—ã¦ã‚·ã‚§ãƒ¼ãƒ€ã‚’é©ç”¨
ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚²ãƒ¼ãƒ ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’æç”»ã—ã€ãã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚·ãƒ¼ãƒ³ã«æç”»ã™ã‚‹éš›ã«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚²ãƒ¼ãƒ ç”»é¢å…¨ä½“ã«å¾Œå‡¦ç†ã¨ã—ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é©ç”¨ã§ãã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/15.png?raw=true)

```C++
# include <Siv3D.hpp>

// æ¸¦å·»ãåŠ¹æœã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ç”¨ã®
// å®šæ•°ãƒãƒƒãƒ•ã‚¡ (PS_1)
struct Swirl
{
	// å›è»¢
	float angle;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã‚’
	// 16 ã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
	Float3 unused = {};
};

void Main()
{
	// ã‚²ãƒ¼ãƒ ã®æç”»ç”¨ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	MSRenderTexture rt(Scene::Size());

	// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader psGrayscale(U"example/shader/2d/grayscale" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 } });
	if (!psGrayscale)
	{
		throw Error(U"Failed to load a shader file");
	}

	// æ¸¦å·»ãåŠ¹æœã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã¯ã€Windows ã§ã¯ hlsl, macOS/Linux ã§ã¯ frag ã‚’é¸æŠ
	// {} å†…ã¯å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®åå‰ã¨ã€å¯¾å¿œã™ã‚‹å®šæ•°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	const PixelShader psSwirl(U"example/shader/2d/swirl" SIV3D_SELECT_SHADER(U".hlsl", U".frag"),
		{ { U"PSConstants2D", 0 }, { U"Swirl", 1 } });
	if (!psSwirl)
	{
		throw Error(U"Failed to load a shader file");
	}

	// æ¸¦å·»ãåŠ¹æœã®ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ç”¨ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ConstantBuffer<Swirl> cb;

	// ã‚¬ã‚¦ã‚¹ã¼ã‹ã—ã®ä¸­é–“ã§ä½¿ã†ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	RenderTexture rtA(rt.size()), rtB(rt.size());
	RenderTexture rtA4(rt.size() / 4), rtB4(rt.size() / 4);
	RenderTexture rtA8(rt.size() / 8), rtB8(rt.size() / 8);

	// ã‚²ãƒ¼ãƒ ç”»é¢ã«é©ç”¨ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	size_t effectIndex = 0;

	// èƒŒæ™¯è‰²
	constexpr ColorF backgroundColor(0.3, 0.4, 0.5);

	// ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚µã‚¤ã‚º
	constexpr Size blockSize(40, 20);

	// ãƒ–ãƒ­ãƒƒã‚¯ã®é…åˆ—
	Array<Rect> blocks;

	// æ¨ª (Scene::Width() / blockSize.x) å€‹ã€ç¸¦ 5 å€‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…åˆ—ã«è¿½åŠ ã™ã‚‹
	for (auto p : step(Size((Scene::Width() / blockSize.x), 5)))
	{
		blocks << Rect(p.x * blockSize.x, 60 + p.y * blockSize.y, blockSize);
	}

	// ãƒœãƒ¼ãƒ«ã®é€Ÿã•
	constexpr double speed = 480.0;

	// ãƒœãƒ¼ãƒ«ã®é€Ÿåº¦
	Vec2 ballVelocity(0, -speed);

	// ãƒœãƒ¼ãƒ«
	Circle ball(400, 400, 8);

	// è‡ªå‹•ãƒ—ãƒ¬ã‚¤ç”¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	double paddleCenter = 400;
	double randomOffset = 0.0;

	while (System::Update())
	{
		// è‡ªå‹•ãƒ—ãƒ¬ã‚¤
		paddleCenter = Math::Damp(paddleCenter, ball.x + ballVelocity.x*1.2 + randomOffset, 0.9, Scene::DeltaTime());

		// ãƒ‘ãƒ‰ãƒ«
		const RectF paddle(Arg::center(paddleCenter, 500), 120, 10);

		// ãƒœãƒ¼ãƒ«ã‚’ç§»å‹•
		ball.moveBy(ballVelocity * Scene::DeltaTime());

		// ãƒ–ãƒ­ãƒƒã‚¯ã‚’é †ã«ãƒã‚§ãƒƒã‚¯
		for (auto it = blocks.begin(); it != blocks.end(); ++it)
		{
			// ãƒœãƒ¼ãƒ«ã¨ãƒ–ãƒ­ãƒƒã‚¯ãŒäº¤å·®ã—ã¦ã„ãŸã‚‰
			if (it->intersects(ball))
			{
				// ãƒœãƒ¼ãƒ«ã®å‘ãã‚’åè»¢ã™ã‚‹
				(it->bottom().intersects(ball) || it->top().intersects(ball) ? ballVelocity.y : ballVelocity.x) *= -1;

				// ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…åˆ—ã‹ã‚‰å‰Šé™¤ï¼ˆã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒç„¡åŠ¹ã«ãªã‚‹ã®ã§æ³¨æ„ï¼‰
				blocks.erase(it);

				// ã“ã‚Œä»¥ä¸Šãƒã‚§ãƒƒã‚¯ã—ãªã„  
				break;
			}
		}

		// å¤©äº•ã«ã¶ã¤ã‹ã£ãŸã‚‰ã¯ã­è¿”ã‚‹
		if (ball.y < 0 && ballVelocity.y < 0)
		{
			ballVelocity.y *= -1;
		}

		// å·¦å³ã®å£ã«ã¶ã¤ã‹ã£ãŸã‚‰ã¯ã­è¿”ã‚‹
		if ((ball.x < 0 && ballVelocity.x < 0) || (Scene::Width() < ball.x && ballVelocity.x > 0))
		{
			ballVelocity.x *= -1;
		}

		// ãƒ‘ãƒ‰ãƒ«ã«ã‚ãŸã£ãŸã‚‰ã¯ã­è¿”ã‚‹
		if (ballVelocity.y > 0 && paddle.intersects(ball))
		{
			// ãƒ‘ãƒ‰ãƒ«ã®ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ã«å¿œã˜ã¦ã¯ã­è¿”ã‚‹å‘ãã‚’å¤‰ãˆã‚‹
			ballVelocity = Vec2((ball.x - paddle.center().x) * 10, -ballVelocity.y).setLength(speed);
			randomOffset = Random(-40, 40);
		}

		// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚¯ãƒªã‚¢
		rt.clear(backgroundColor);
		{
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ rt ã«è¨­å®š
			ScopedRenderTarget2D target(rt);

			for (auto y : Range(1, 5))
			{
				Line(0, y * 100, 800, y * 100).draw(1, Palette::Gray);
			}

			for (auto x : Range(1, 7))
			{
				Line(x * 100, 0, x * 100, 600).draw(1, Palette::Gray);
			}

			// ã™ã¹ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»ã™ã‚‹
			for (const auto& block : blocks)
			{
				block.stretched(-1).draw(HSV(block.y - 40));
			}

			// ãƒœãƒ¼ãƒ«ã‚’æã
			ball.draw();

			// ãƒ‘ãƒ‰ãƒ«ã‚’æã
			paddle.draw();
		}

		// resolve ã®ãŸã‚ã«æç”»ã‚’å®Œäº†ã•ã›ã‚‹
		Graphics2D::Flush();

		// multi-sample ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ resolve ã—ã¦
		// multi-sample ã§ã¯ãªã„ã€æç”»å¯èƒ½ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å¾—ã‚‹
		rt.resolve();

		if (effectIndex == 0) // ã‚²ãƒ¼ãƒ ç”»é¢ã‚’ãã®ã¾ã¾æç”»
		{
			rt.draw();
		}
		else if (effectIndex == 1) // ã‚²ãƒ¼ãƒ ç”»é¢ã‚’ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã—ã¦æç”»
		{
			// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(psGrayscale);
			
			rt.draw();
		}
		else if (effectIndex == 2) // ã‚²ãƒ¼ãƒ ç”»é¢ã‚’æ¸¦å·»ãåŠ¹æœã§æç”»
		{
			cb->angle = static_cast<float>(Math::Sin(Scene::Time()) * 240_deg);

			// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
			Graphics2D::SetConstantBuffer(ShaderStage::Pixel, 1, cb);
			
			// æ¸¦å·»ãåŠ¹æœã®ã‚·ã‚§ãƒ¼ãƒ€ã‚’é–‹å§‹
			ScopedCustomShader2D shader(psSwirl);
			
			rt.draw();
		}
		else if (effectIndex == 3) // ã‚²ãƒ¼ãƒ ç”»é¢ã‚’ã‚¬ã‚¦ã‚¹ã¼ã‹ã—ã§æç”»
		{
			// [ã‚ªãƒªã‚¸ãƒŠãƒ«]->[ã‚¬ã‚¦ã‚¹ã¼ã‹ã—]->[1/4ã‚µã‚¤ã‚º]->[ã‚¬ã‚¦ã‚¹ã¼ã‹ã—]
			Shader::GaussianBlur(rt, rtB, rtA);
			Shader::Downsample(rtA, rtA4);
			Shader::GaussianBlur(rtA4, rtB4, rtA4);
			Shader::Downsample(rtA4, rtA8);
			Shader::GaussianBlur(rtA8, rtB8, rtA8);

			rtA8.scaled(8).draw();
		}

		// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç¨®é¡ã®é¸æŠ
		SimpleGUI::RadioButtons(effectIndex, { U"Default", U"Grayscale", U"Swirl", U"GaussianBlur" }, Vec2(10, 10));
	}
}
```


## 5. å­ãƒ—ãƒ­ã‚»ã‚¹ã®ä½œæˆ
åˆ¥ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€Œå­ãƒ—ãƒ­ã‚»ã‚¹ã€ã¨ã—ã¦èµ·å‹•ã€ç®¡ç†ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚åˆ¥ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•ã—ãŸã‚Šã€åˆ¥ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨æƒ…å ±ã‚’ã‚„ã‚Šå–ã‚Šã™ã‚‹éš›ã«ä½¿ãˆã¾ã™ã€‚

```C++
# include <Siv3D.hpp>

void Main()
{
# if SIV3D_PLATFORM(WINDOWS)

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
	const FilePath path = U"C:/Windows/System32/notepad.exe";

# elif SIV3D_PLATFORM(MACOS)

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
	const FilePath path = U"/Applications/Calculator.app/Contents/MacOS/Calculator";

# endif

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆ
	ChildProcess child = Process::Spawn(path);

	if (!child)
	{
		throw Error(U"Failed to create a process");
	}

	while (System::Update())
	{
		ClearPrint();

		// ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œä¸­ã‹ã‚’å–å¾—
		Print << child.isRunning();

		// ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸå ´åˆã€ãã®çµ‚äº†ã‚³ãƒ¼ãƒ‰
		Print << child.getExitCode();

		if (child.isRunning())
		{
			if (SimpleGUI::Button(U"Terminate", Vec2(100, 20)))
			{
				// ãƒ—ãƒ­ã‚»ã‚¹ã‚’å¼·åˆ¶çµ‚äº†
				child.terminate();
			}
		}
	}
}
```

### å­ãƒ—ãƒ­ã‚»ã‚¹ã¨ã®æ¨™æº–å…¥å‡ºåŠ›ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†
å­ãƒ—ãƒ­ã‚»ã‚¹ã¨ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†ã«ã‚ˆã£ã¦ã€ä¸€æ–¹ã®æ¨™æº–å‡ºåŠ›ã‚’ä»–æ–¹ã®æ¨™æº–å…¥åŠ›ã¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ã€"Console" ã¯é€šå¸¸ã® C++ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ãƒ“ãƒ«ãƒ‰ã—ã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/16.png?raw=true)

```C++ tab="Console"
# include <iostream>

int main()
{
    int a, b;
    std::cin >> a >> b;
    std::cout << (a + b) << std::endl;
}
```

```C++ tab="Siv3D"
# include <Siv3D.hpp>

void Main()
{
# if SIV3D_PLATFORM(WINDOWS)

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
	const FilePath path = U"Console.exe";

# else

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
	const FilePath path = U"Console";

# endif

	// å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆï¼ˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†ï¼‰
	ChildProcess child = Process::Spawn(path, Pipe::StdInOut);

	if (!child)
	{
		throw Error(U"Failed to create a process");
	}

	child.ostream() << 10 << std::endl;
	child.ostream() << 20 << std::endl;

	int32 result;
	child.istream() >> result;
	Print << U"result: " << result;

	while (System::Update())
	{

	}
}
```


## 6. å®Ÿé¨“çš„ãª 3D æç”»å¯¾å¿œ
å®Ÿé¨“çš„ãª 3D æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¾ã—ãŸã€‚ãŸã ã—ã€2D æç”»ã§ 3D ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ç°¡æ˜“çš„ãªã‚‚ã®ãªã®ã§ã€æ¬¡ã®ã‚ˆã†ãªåˆ¶ç´„ãŒã‚ã‚Šã¾ã™ã€‚

- æ·±åº¦ãƒãƒƒãƒ•ã‚¡ãŒç„¡ã„ã®ã§å‰å¾Œåˆ¤å®šãŒã§ããªã„
- é è¿‘ã‚¯ãƒªãƒƒãƒ—ãŒç„¡ã„ã®ã§ã‚«ãƒ¡ãƒ©ã«è¿‘ã™ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œãªã„


### 3D Triangles

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/17.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	constexpr std::array<Vec3, 8> vertices =
	{
		Vec3(-1, 1, -1),
		Vec3(1, 1, -1),
		Vec3(-1, -1, -1),
		Vec3(1, -1, -1),
		Vec3(1, 1, 1),
		Vec3(-1, 1, 1),
		Vec3(1, -1, 1),
		Vec3(-1, -1, 1),
	};

	constexpr std::array<uint32, 36> indices =
	{
		0, 1, 2, 2, 1, 3,
		5, 4, 0, 0, 4, 1,
		1, 4, 3, 3, 4, 6,
		5, 0, 7, 7, 0, 2,
		4, 5, 6, 6, 5, 7,
		2, 3, 7, 7, 3, 6,
	};

	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(0, 0, 0);
	Vec3 eyePosition(0, 4, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(8, Scene::Time() * 30_deg, Math::Sin(Scene::Time()) * 4);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto i : step(12))
			{
				const Vec3 p0(vertices[indices[i * 3 + 0]]);
				const Vec3 p1(vertices[indices[i * 3 + 1]]);
				const Vec3 p2(vertices[indices[i * 3 + 2]]);

				experimental::Triangle3D(p0, p1, p2).draw(mat, HSV(i * 30));
			}
		}
	}
}
```


### 3D AABB

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/18.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(0, 0, 0);
	Vec3 eyePosition(0, 10, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(20, Scene::Time() * 30_deg, 8 + Periodic::Sine0_1(4s) * 8);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto i : Range(-10, 10))
			{
				experimental::Line3D(Vec3(-10, 0, i), Vec3(10, 0, i)).draw(mat, ColorF(0.5));
				experimental::Line3D(Vec3(i, 0, -10), Vec3(i, 0, 10)).draw(mat, ColorF(0.5));
			}

			experimental::AABB(Vec3(0, 1, 0), Vec3(2, 2, 2)).draw(mat, Palette::White);
			experimental::AABB(Vec3(-8, 1, 8), Vec3(2, 2, 2)).draw(mat, HSV(0));
			experimental::AABB(Vec3(8, 1, 8), Vec3(2, 2, 2)).draw(mat, HSV(90));
			experimental::AABB(Vec3(8, 1, -8), Vec3(2, 2, 2)).draw(mat, HSV(270));
			experimental::AABB(Vec3(-8, 1, -8), Vec3(2, 2, 2)).draw(mat, HSV(180));
		}
	}
}
```


### 3D Terrain
ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯ã§ã€å·¦ä¸Šã®é«˜ã•ãƒãƒƒãƒ—ã«å±±ã‚’æãã¾ã™ã€‚

![](https://github.com/Siv3D/siv3d.docs.images/blob/master/news/v041/19.png?raw=true)

```C++
# include <Siv3D.hpp>

void Main()
{
	Window::Resize(1280, 720);
	Scene::SetBackground(ColorF(0.05, 0.3, 0.7));

	RenderTexture rt(100, 100, ColorF(0.0), TextureFormat::R32_Float);
	Grid<float> heightMap;
	Grid<Float3> positions;

	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(50, 0, -50);
	Vec3 eyePosition(0, 100, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(Arg::r = 80, Arg::phi = Scene::Time() * 30_deg, Arg::y = 50) + Vec3(50, 0, -50);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		rt.read(heightMap);
		{
			positions.resize(heightMap.size());

			for (auto p : step(heightMap.size()))
			{
				positions[p] = Float3(p.x, heightMap[p], -p.y);
			}
		}

		{
			ScopedRenderTarget2D target(rt);
			ScopedRenderStates2D blend(BlendState::Additive);

			if (MouseL.pressed())
			{
				Circle(Cursor::Pos(), 8).draw(ColorF(Scene::DeltaTime() * 24.0));
			}
		}

		if (positions)
		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto x : step(positions.width() - 1))
			{
				for (auto y : step(positions.height()))
				{
					const Float3 begin = positions[{x, y}];
					const Float3 end = positions[{x + 1, y}];
					const ColorF color = HSV(120 - (begin.y + end.y) * 3, 0.75, 0.7);
					experimental::Line3D(begin, end).draw(mat, color);
				}
			}

			for (auto x : step(positions.width()))
			{
				for (auto y : step(positions.height() - 1))
				{
					const Float3 begin = positions[{x, y}];
					const Float3 end = positions[{x, y + 1}];
					const ColorF color = HSV(120 - (begin.y + end.y) * 3, 0.75, 0.7);
					experimental::Line3D(begin, end).draw(mat, color);
				}
			}
		}

		rt.draw(ColorF(0.1));
	}
}
```

