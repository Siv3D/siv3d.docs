description: OpenSiv3D v0.4.2 ã®æ–°æ©Ÿèƒ½ã®è§£èª¬ã¨ã‚µãƒ³ãƒ—ãƒ«

## 1. SDFFont
`SDFFont` ã¯ã€ã‚°ãƒªãƒ•ã®ç”»åƒã‚’ Distance field å½¢å¼ã§æŒã¤ `Font` ã‚¯ãƒ©ã‚¹ã§ã™ã€‚  
ã“ã‚Œã¾ã§ã® `Font` ã‚¯ãƒ©ã‚¹ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§æŒ‡å®šã—ãŸå›ºå®šã‚µã‚¤ã‚ºã§ã‚°ãƒªãƒ•ã”ã¨ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ç”»åƒã‚’ç”Ÿæˆã—ã€ãã‚Œã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ãŸã‚ã€æ‹¡å¤§æç”»æ™‚ã«ã¼ã‚„ã‘ã‚‹ãªã©ã€ã‚µã‚¤ã‚ºã®å¤‰æ›´ã«å¼±ãã€ç¸å–ã‚Šã®ã‚ˆã†ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é©ç”¨ã™ã‚‹ã“ã¨ã‚‚å›°é›£ã§ã—ãŸã€‚  
`SDFFont` ã‚¯ãƒ©ã‚¹ã¯ã€ã‚°ãƒªãƒ•ã”ã¨ã® Distance Field ã‚’ç”Ÿæˆã—ã€æ‹¡å¤§ã—ã¦ã‚‚ã¼ã‚„ã‘ãªã„æ‰‹æ³•ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚`draw()` ã”ã¨ã«ç¬¬ä¸€å¼•æ•°ã§ãƒ•ã‚©ãƒ³ãƒˆã®ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã§ãã€å¤§ããªå€¤ã‚’å…¥ã‚Œã¦ã‚‚çµæœãŒã¼ã‚„ã‘ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€`Garphics2D::SetSDFParameters()` ã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã™ã‚‹ã“ã¨ã§ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã«æ–‡å­—ã‚’å¤ªã‚‰ã›ã‚‰ã‚Œã¾ã™ã€‚å¤ªã•ã¨è‰²ã‚’å¤‰ãˆã¦ 2 å›ä»¥ä¸Šãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»ã™ã‚‹ã“ã¨ã§ã€ç¸å–ã‚Šã®è¡¨ç¾ã‚‚å¯èƒ½ã§ã™ã€‚  
ãŸã ã—ã€`SDFFont` ã®ç”Ÿæˆã‚„æç”»ã®ã‚³ã‚¹ãƒˆã¯ `Font` ã«æ¯”ã¹ã¦å¤§ãã„ãŸã‚ã€`Font` ã§ååˆ†ãªã‚±ãƒ¼ã‚¹ã§ã¯å¾“æ¥é€šã‚Š `Font` ã‚’ä½¿ã†ã¹ãã§ã™ã€‚  
`SDFFont` ã®å“è³ªã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§æŒ‡å®šã™ã‚‹ã‚°ãƒªãƒ•ã® Distance Field ã®ã‚µã‚¤ã‚ºã¨ã€æç”»ã™ã‚‹å­—å½¢ã®è¤‡é›‘ã•ã«å½±éŸ¿ã•ã‚Œã¾ã™ã€‚ç”»æ•°ã®å°‘ãªã„æ•°å­—ã‚„ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã€æ›²ç·šçš„ã§ã‚·ãƒ³ãƒ—ãƒ«ãªå­—å½¢ã§ã‚ã‚Œã°ã€40 ãƒ”ã‚¯ã‚»ãƒ«ä»¥ä¸‹ã® Distance Field ã§ã‚‚ãã‚Œã„ãªãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§ãã¾ã™ãŒã€è¤‡é›‘ãªå­—å½¢ã«ãªã‚‹ã»ã©ã€å°ã•ãª Distance Field ã§ã¯æç”»çµæœãŒä¹±ã‚ŒãŸã‚Šã€ãƒã‚¤ã‚ºãŒç›®ç«‹ã¤ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚æ–‡å­—ã®å¤ªã‚‰ã›ã«ã¤ã„ã¦ã‚‚ã€å¤§ãã„å€¤ã§ã¯ãƒã‚¤ã‚ºãŒç›®ç«‹ã¤ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚`SDFFont` ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ã™ã‚‹éš›ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã®æç”»çµæœã‚’ãƒã‚§ãƒƒã‚¯ã—ã€é©åˆ‡ãª Distance Field ã‚µã‚¤ã‚ºã‚’è¨­å®šã—ã¾ã—ã‚‡ã†ã€‚

### SDFFont ã®åŸºæœ¬

![](images/042-01.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.4, 0.5, 0.6));

	// ã‚°ãƒªãƒ•ã”ã¨ã® Distance field ã®ã‚µã‚¤ã‚º
	const int32 distanceFieldSize = 60;
	
	// SDFFont
	const SDFFont sdfFont(distanceFieldSize, Typeface::Bold);

	const String text = U"OpenSiv3D";

	while (System::Update())
	{
		// SDF ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
		Graphics2D::SetSDFParameters(sdfFont.pixelRange());
		sdfFont(text).draw(40, Vec2(20, 20));
		sdfFont(text).draw(80, Vec2(20, 80));
		sdfFont(text).draw(120, Vec2(20, 180));

		// SDF ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®šã€å¤ªã‚‰ã›ã‚’ 0.2 ã«
		Graphics2D::SetSDFParameters(sdfFont.pixelRange(), 0.2);
		sdfFont(text).draw(120, Vec2(20, 320), Palette::Black);

		// SDF ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®šã€å¤ªã‚‰ã›ã‚’ 0.0 ã«
		Graphics2D::SetSDFParameters(sdfFont.pixelRange(), 0.0);
		sdfFont(text).draw(120, Vec2(20, 320));
	}
}
```

### SDFFont ã®äº‹å‰ç”Ÿæˆ
`SDFFont` ã®å„ã‚°ãƒªãƒ•ã® Distance field ã¯ã€ç”Ÿæˆã«æ™‚é–“ãŒã‹ã‹ã‚‹ãŸã‚ã€ä½¿ç”¨ã™ã‚‹ã‚°ãƒªãƒ•ã‚’ã‚ã‚‰ã‹ã˜ã‚ç”Ÿæˆã—ã¦ä¿å­˜ã—ã¦ãŠãã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é€Ÿåº¦ä½ä¸‹ãŒé˜²ã’ã¾ã™ã€‚`SDFFont::preload(s)` ã§ã€æ–‡å­—åˆ— `s` å«ã¾ã‚Œã‚‹ã‚°ãƒªãƒ•ã® Distance field ã‚’ç”Ÿæˆã€`SDFFont::preload(imagePath, jsonPath)` ã§ 2 ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ç”Ÿæˆçµæœã‚’ä¿å­˜ã—ã€`SDFFont` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚äº‹å‰ç”Ÿæˆã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚°ãƒªãƒ•ã¯å®Ÿè¡Œæ™‚ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚

![](images/042-02.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.4, 0.5, 0.6));

	// ã‚°ãƒªãƒ•ã”ã¨ã® Distance field ã®ã‚µã‚¤ã‚º
	const int32 distanceFieldSize = 60;

	//////////////////////////////////////////
	//
	// SDFFont Distance field ã®äº‹å‰ç”Ÿæˆ
	//
	// â€» ä¿å­˜ã§ããŸã‚‰ä¸è¦ãªã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
	{
		String s;
		for (auto i : Range(32, 126))
		{
			s << char32(i);
		}

		// SDF ã®ä½œæˆã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ã€
		// ASCII æ–‡å­—ã‚’ã‚ã‚‰ã‹ã˜ã‚ SDF åŒ–ã—ã¦ã€ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ã‚’ä¿å­˜ã—ã¦ãŠã
		SDFFont(distanceFieldSize, Typeface::Bold)
			.preload(s)
			.saveGlyphs(U"sdf-font/bold_60.png", U"sdf-font/bold_60.json");
	}
	//
	//////////////////////////////////////////
	
	// SDFFont ã‚’ä½œæˆã—ã€äº‹å‰ç”Ÿæˆã—ãŸ Distance field ã‚’ãƒ­ãƒ¼ãƒ‰
	// ãƒ•ã‚©ãƒ³ãƒˆã®ç¨®é¡ã‚„ Distance field ãŒä¸€è‡´ã—ãªã„ã¨ã„ã‘ãªã„
	const SDFFont sdfFont({ U"sdf-font/bold_60.png", U"sdf-font/bold_60.json" }, distanceFieldSize, Typeface::Bold);

	if (!sdfFont) // ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸã‚‰
	{
		throw Error(U"Failed to load SDFFont");
	}

	const String text = U"OpenSiv3D";

	while (System::Update())
	{
		// SDF ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
		Graphics2D::SetSDFParameters(sdfFont.pixelRange());
		sdfFont(text).draw(120, Vec2(20, 20));
	}
}
```


### æ¯”è¼ƒç”¨ã‚µãƒ³ãƒ—ãƒ«

![](images/042-03.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Window::Resize(1280, 720);
	Scene::SetBackground(ColorF(0.4, 0.5, 0.6));

	constexpr Vec2 pos(0, 0);
	const String text = U"OpenSiv3D\nã‚ã„ã†ãˆãŠ";

	//////////////////////////////////////////
	//
	// SDFFont Distance field ã®äº‹å‰ç”Ÿæˆ
	//
	// â€» ä¿å­˜ã§ããŸã‚‰ä¸è¦ãªã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
	{
		String s;
		for (auto i : Range(32, 126))
		{
			s << char32(i);
		}
		s += text;

		// SDF ã®ä½œæˆã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ã€
		// ASCII æ–‡å­—ã¨ text ã‚’ã‚ã‚‰ã‹ã˜ã‚ SDF åŒ–ã—ã¦ã€ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ã‚’ä¿å­˜ã—ã¦ãŠã
		SDFFont(60, Typeface::Light).preload(s).saveGlyphs(U"sdf-font/light_60.png", U"sdf-font/light_60.json");
		SDFFont(60, Typeface::Heavy).preload(s).saveGlyphs(U"sdf-font/heavy_60.png", U"sdf-font/heavy_60.json");
		SDFFont(50, U"example/font/LogoTypeGothic/LogoTypeGothic.otf").preload(s).saveGlyphs(U"sdf-font/logo_50.png", U"sdf-font/logo_50.json");
	}
	//
	//////////////////////////////////////////

	// SDFFont ã‚’ä½œæˆã—ã€äº‹å‰ç”Ÿæˆã—ãŸ Distance field ã‚’ãƒ­ãƒ¼ãƒ‰
	const Array<SDFFont> sdfFonts =
	{
		SDFFont({ U"sdf-font/light_60.png", U"sdf-font/light_60.json" }, 60, Typeface::Light),
		SDFFont({ U"sdf-font/heavy_60.png", U"sdf-font/heavy_60.json" }, 60, Typeface::Heavy),
		SDFFont({ U"sdf-font/logo_50.png", U"sdf-font/logo_50.json" }, 50, U"example/font/LogoTypeGothic/LogoTypeGothic.otf"),
	};

	for (const auto& sdfFont : sdfFonts)
	{
		if (!sdfFont) // ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸã‚‰
		{
			throw Error(U"Failed to load SDFFont");
		}
	}

	// æ¯”è¼ƒç”¨ã®é€šå¸¸ Font
	const Array<Font> fonts =
	{
		Font(60, Typeface::Light),
		Font(60, Typeface::Heavy),
		Font(50, U"example/font/LogoTypeGothic/LogoTypeGothic.otf"),
	};

	size_t fontIndex = 0, method = 0;
	double fontSize = 80, outline1 = 0.0, outline2 = 0.0;
	HSV innerColor = Palette::Black, outlineColor = Palette::White;

	while (System::Update())
	{
		const auto& sdfFont = sdfFonts[fontIndex];
		const auto& font = fonts[fontIndex];

		if (method == 0)
		{
			Graphics2D::SetSDFParameters(sdfFont.pixelRange(), outline2);
			sdfFont(text).draw(fontSize, pos, innerColor);

			Graphics2D::SetSDFParameters(sdfFont.pixelRange(), outline1);
			sdfFont(text).draw(fontSize, pos, outlineColor);

			Graphics2D::SetSDFParameters(sdfFont.pixelRange());
			sdfFont(text).draw(fontSize, pos, innerColor);
		}
		else if (method == 1)
		{
			Transformer2D tr(Mat3x2::Scale(fontSize / font.fontSize()));
			font(text).draw(pos, innerColor);
		}

		SimpleGUI::RadioButtons(fontIndex, { U"Light 60", U"Heavy 60", U"Logo 50" }, Vec2(20, 360), 150);
		SimpleGUI::RadioButtons(method, { U"SDFFont", U"Font" }, Vec2(20, 480), 150);
		SimpleGUI::Slider(U"size: {:.0f}"_fmt(fontSize), fontSize, 15, 550, Vec2(20, 560), 150, 200);
		SimpleGUI::Slider(U"outline1: {:.2f}"_fmt(outline1), outline1, 0.0, 0.49, Vec2(20, 600), 150, 200, (method == 0));
		SimpleGUI::Slider(U"outline2: {:.2f}"_fmt(outline2), outline2, 0.0, 0.49, Vec2(20, 640), 150, 200, (method == 0));
		SimpleGUI::ColorPicker(innerColor, Vec2(400, 560));
		SimpleGUI::ColorPicker(outlineColor, Vec2(580, 560));
	}
}
```


## 2. é›†ä¸­ç·šæç”»
å®Ÿé¨“çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç¾¤ HamFramework ã«è¿½åŠ ã•ã‚ŒãŸ `SaturatedLinework` ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ã€ã‚³ãƒŸã‚«ãƒ«ãªåŠ¹æœã‚„ç–¾èµ°æ„Ÿã‚’æ¼”å‡ºã™ã‚‹ãŸã‚ã®é›†ä¸­ç·šã‚’ç°¡å˜ã«æç”»ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚è¨­å®šã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å›³å½¢ã€å¤–å‘¨ã®é•·æ–¹å½¢ã€ç·šã®æœ¬æ•°ã€ç·šã®å¤ªã•ã€é•·ã•ã®ã°ã‚‰ã¤ãã€ä¹±æ•°ã‚·ãƒ¼ãƒ‰ãªã©ãŒã‚ã‚Šã€`.draw()` ã®å¼•æ•°ã§è‰²ã‚’æŒ‡å®šã§ãã¾ã™ã€‚å¤šæ•°ã®ä¸‰è§’å½¢ã‚’ç”Ÿæˆã—ã¦æç”»ã™ã‚‹æ–¹æ³•ã§è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã—ãªã‘ã‚Œã°ã€ç”Ÿæˆã—ãŸä¸‰è§’å½¢ã¯å†åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚

![](images/042-04.png)

```C++
# include <Siv3D.hpp>
# include <HamFramework.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.98, 0.96, 0.94));

	// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å›³å½¢
	Ellipse target(400, 300, 180, 120);

	// å¤–å‘¨ã®é•·æ–¹å½¢
	Rect outer = Scene::Rect();

	// ç·šã®å¤ªã•
	double minThickness = 3.0, maxThickness = 10.0;
	
	// ç·šã®æœ¬æ•°
	double lineCount = 150;

	// ç·šã®é•·ã•ã®ã°ã‚‰ã¤ã
	double offsetRange = 60.0;

	// ä¹±æ•°ã‚·ãƒ¼ãƒ‰
	uint64 seed = 12345;

	SaturatedLinework<Ellipse> linework(target, outer);
	linework
		.setThickness(minThickness, maxThickness)
		.setLineCount(static_cast<size_t>(lineCount))
		.setOffsetRange(offsetRange);

	const Texture texture(Emoji(U"ğŸ¦€"));

	while (System::Update())
	{
		if (MouseR.down())
		{
			target.setCenter(Cursor::Pos());
			linework.setTargetShape(target);
		}

		texture.scaled(1.6).drawAt(target.center);

		// é›†ä¸­ç·šã‚’æç”»
		linework.draw(ColorF(0.1));

		if (SimpleGUI::Slider(U"lineCount", lineCount, 0.0, 400.0, Vec2(20, 20), 150))
		{
			linework.setLineCount(static_cast<size_t>(lineCount));
		}

		if (SimpleGUI::Slider(U"offsetRange", offsetRange, 0.0, 100.0, Vec2(20, 60), 150))
		{
			linework.setOffsetRange(offsetRange);
		}

		if (SimpleGUI::Button(U"Change seed", Vec2(20, 100)))
		{
			seed = RandomUint64();
			linework.setSeed(seed);
		}
	}
}
```


## 3. ã‚·ãƒªã‚¢ãƒ«é€šä¿¡
ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ã‚’ä½¿ã£ã¦ã€å¤–éƒ¨ãƒ‡ãƒã‚¤ã‚¹ã¨ãƒ‡ãƒ¼ã‚¿ã®é€å—ä¿¡ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ä»¥ä¸‹ã§ã¯ Arduino UNO ã§ LED ã®ç‚¹ç¯/æ¶ˆç¯ã‚’ PC ã‹ã‚‰åˆ¶å¾¡ã—ã€åˆã‚ã›ã¦ 1 ãƒã‚¤ãƒˆã®æ•°å€¤ãƒ‡ãƒ¼ã‚¿ã‚’ã‚„ã‚Šå–ã‚Šã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚’ç¤ºã—ã¾ã™ã€‚

### Arduino ã®ã‚³ãƒ¼ãƒ‰

```C++
void setup()
{
	pinMode(13, OUTPUT); // 13 ãƒ”ãƒ³ - LED - æŠµæŠ— - GND

	// 9600bps ã§ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã‚’é–‹ã
	Serial.begin(9600);
}

unsigned char i = 0; // ãƒ†ã‚¹ãƒˆç”¨ã« PC å´ã«é€ã‚‹å€¤

void loop()
{
	// 250 ãƒŸãƒªç§’æ­¢ã‚ã‚‹
	delay(250);

	// ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã« 1 ãƒã‚¤ãƒˆå‡ºåŠ›
	Serial.write(i);

	++i;

	// ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ã§å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	const int val = Serial.read();

	if (val == -1) // å—ä¿¡ã—ãŸãƒ‡ãƒ¼ãŒç„¡ã„
	{
		return;
	}

	if (val == 0)
	{
		digitalWrite(13, LOW); // LOW ã‚’å‡ºåŠ›
	}
	else if (val == 1)
	{
		digitalWrite(13, HIGH); // HIGH ã‚’å‡ºåŠ›
	}
	else if (val == 2)
	{
		i = 0;
	}
}
```

### PC å´ã®ã‚³ãƒ¼ãƒ‰

```C++
# include <Siv3D.hpp>

void Main()
{
	// ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã®ä¸€è¦§ã‚’å–å¾—
	const Array<SerialPortInfo> infos = System::EnumerateSerialPorts();
	const Array<String> options = infos.map([](const SerialPortInfo& info)
	{
		return U"{} ({})"_fmt(info.port, info.description);
	}) << U"none";

	Serial serial;
	size_t index = (options.size() - 1);

	while (System::Update())
	{
		const bool isOpened = serial.isOpened();

		if (SimpleGUI::Button(U"Write 0", Vec2(200, 20), 120, isOpened))
		{
			// 1 ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ (0) ã‚’æ›¸ãè¾¼ã‚€
			serial.writeByte(0);
		}

		if (SimpleGUI::Button(U"Write 1", Vec2(340, 20), 120, isOpened))
		{
			// 1 ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ (1) ã‚’æ›¸ãè¾¼ã‚€
			serial.writeByte(1);
		}

		if (SimpleGUI::Button(U"Write 2", Vec2(480, 20), 120, isOpened))
		{
			// 1 ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ (2) ã‚’æ›¸ãè¾¼ã‚€
			serial.writeByte(2);
		}

		if (SimpleGUI::RadioButtons(index, options, Vec2(200, 60)))
		{
			ClearPrint();

			if (index == (options.size() - 1))
			{
				serial = Serial();
			}
			else
			{
				Print << U"Open {}"_fmt(infos[index].port);

				// ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã‚’ã‚ªãƒ¼ãƒ—ãƒ³
				if (serial.open(infos[index].port))
				{
					Print << U"Succeeded";
				}
				else
				{
					Print << U"Failed";
				}
			}
		}

		if (const size_t available = serial.available())
		{
			// ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ã§å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤º
			Print << U"READ: " << serial.readBytes();
		}
	}
}
```


## 4. PoissonDisk2D
ã»ã©ã‚ˆã„è·é›¢ã§é‡ãªã‚‰ãªã„ç‚¹ç¾¤ã‚’ç”Ÿæˆã™ã‚‹ `PoissonDisk2D` ã‚¯ãƒ©ã‚¹ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚

![](images/042-05.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.2, 0.3, 0.4));

	const Rect rect(100, 100, 600, 400);

	double r = 15.0;

	// ç‚¹ç¾¤ã‚’ç”Ÿæˆ
	PoissonDisk2D pd(rect.size, r);

	while (System::Update())
	{
		rect.drawFrame(1, 1, ColorF(0.2));

		for (const auto& point : pd.getPoints())
		{
			Circle(point, r / 4).movedBy(rect.pos).draw();
		}

		if (SimpleGUI::Slider(r, 5.0, 40.0, Vec2(10, 10)))
		{
			pd = PoissonDisk2D(rect.size, r);
		}
	}
}
```


## 5. JSONWriter
æˆå½¢ã•ã‚ŒãŸ JSON ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡ºåŠ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚é †æ¬¡å‡ºåŠ›ã®ãŸã‚ã€å®Ÿéš›ã«ä¿å­˜ã•ã‚Œã‚‹ã®ã¨åŒã˜é †ç•ªã§ãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›ã‚’ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```C++
# include <Siv3D.hpp>

void Main()
{
	JSONWriter json;

	json.startObject();
	{
		json.key(U"Window").startObject();
		{
			json.key(U"title").write(U"My application");
			json.key(U"width").write(800);
			json.key(U"height").write(600);
			json.key(U"sizable").write(false);
		}
		json.endObject();

		json.key(U"Scene").startObject();
		{
			json.key(U"background").write(ColorF(0.8, 0.9, 1.0));
		}
		json.endObject();

		json.key(U"Array").startObject();
		{
			json.key(U"values").writeArray({ 11, 22, 33, 44, 55 });
		}
		json.endObject();

		json.key(U"Items").startArray();
		{
			json.startObject();
			{
				json.key(U"label").write(U"Forest");

				json.key(U"pos").startObject();
				{
					json.key(U"x").write(100);
					json.key(U"y").write(100);
				}
				json.endObject();
			}
			json.endObject();

			json.startObject();
			{
				json.key(U"label").write(U"Ocean");

				json.key(U"pos").startObject();
				{
					json.key(U"x").write(300);
					json.key(U"y").write(200);
				}
				json.endObject();
			}
			json.endObject();

			json.startObject();
			{
				json.key(U"label").write(U"Mountain");

				json.key(U"pos").startObject();
				{
					json.key(U"x").write(500);
					json.key(U"y").write(100);
				}
				json.endObject();
			}
			json.endObject();
		}
		json.endArray();
	}
	json.endObject();

	// ã“ã“ã¾ã§ã®å†…å®¹ã‚’ä¿å­˜
	json.save(U"test.json");

	while (System::Update())
	{

	}
}
```

å‡ºåŠ›ã•ã‚Œã‚‹ JSON ãƒ•ã‚¡ã‚¤ãƒ«
```JSON
{
  "Window": {
    "title": "My application",
    "width": 800,
    "height": 600,
    "sizable": "false"
  },
  "Scene": {
    "background": "(0.8, 0.9, 1, 1)"
  },
  "Array": {
    "values": [
      11,
      22,
      33,
      44,
      55
    ]
  },
  "Items": [
    {
      "label": "Forest",
      "pos": {
        "x": 100,
        "y": 100
      }
    },
    {
      "label": "Ocean",
      "pos": {
        "x": 300,
        "y": 200
      }
    },
    {
      "label": "Mountain",
      "pos": {
        "x": 500,
        "y": 100
      }
    }
  ]
}
```


## 6. Geometry2D::IsClockwise()
é ‚ç‚¹ã®é…åˆ—ãŒæ™‚è¨ˆå›ã‚Šã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚

![](images/042-06.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.96, 0.98, 1.0));
	
	Array<Vec2> points;

	while (System::Update())
	{
		if (MouseL.down())
		{
			points << Cursor::Pos();
		}

		if (MouseR.down())
		{
			points.clear();
		}

		const bool isClockwise = Geometry2D::IsClockwise(points);

		ClearPrint();
		Print << isClockwise;

		for (const auto& point : points)
		{
			Circle(point, 10).draw(Palette::Orange);
		}

		if (points.size() > 2)
		{
			// æ™‚è¨ˆå›ã‚Šã«ãªã‚‹ã‚ˆã†ã«çŸ¢å°ã§ã¤ãªã
			if (isClockwise)
			{
				for (size_t i = 0; i < points.size(); ++i)
				{
					Line(points[i], points[(i + 1) % points.size()])
						.stretched(-10)
						.drawArrow(3, Vec2::All(20), ColorF(0.25));
				}
			}
			else
			{
				for (size_t i = 0; i < points.size(); ++i)
				{
					Line(points[i], points[(i + 1) % points.size()])
						.reversed()
						.stretched(-10)
						.drawArrow(3, Vec2::All(20), ColorF(0.25));
				}
			}
		}
	}
}
```


## 7. Circle::draw(innerColor, outerColor)
`Circle` ã‚„ `Ellipse` ã§ä¸­å¿ƒã®è‰²ã¨å¤–å‘¨ã®è‰²ã‚’æŒ‡å®šã—ã€ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§æç”»ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

![](images/042-07.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		// ä¸­å¿ƒãŒé»„è‰²ã€å¤–å‘¨ãŒé»’
		Circle(Scene::Center(), 400).draw(Palette::Yellow, Palette::Black);
	}
}
```


## 8. SimpleGUI::Headline / ColorPicker
SimpleGUI ã«ã€è¦‹å‡ºã—ã‚’ä»˜ã‘ã‚‹ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒ³ã¨ã€è‰²ã‚’é¸æŠã™ã‚‹ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚

![](images/042-08.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	double p0 = 1.0, p1 = 0.4, p2 = 0.5;
	HSV hsv = Palette::Gray;
	size_t index = 0;

	while (System::Update())
	{
		Scene::SetBackground(hsv);

		// Headline
		SimpleGUI::Headline(U"Config", Vec2(20, 20));
		{
			SimpleGUI::Slider(U"Param1", p0, Vec2(20, 60));
			SimpleGUI::Slider(U"Param2", p1, Vec2(20, 100));
			SimpleGUI::Slider(U"Param3", p2, Vec2(20, 140));
		}

		SimpleGUI::Headline(U"Background", Vec2(240, 20));
		{
			// ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼
			SimpleGUI::ColorPicker(hsv, Vec2(240, 60));
		}

		SimpleGUI::Headline(U"Terrain", Vec2(420, 20));
		{
			SimpleGUI::RadioButtons(index, { U"Plain", U"Hill", U"Mountain" }, Vec2(420, 60), 150);
		}
	}
}
```


## 9. ToastNotification
Windows ã§ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ã‚’å‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

![](images/042-09.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.9, 0.6, 0.3));
	
	// é€šçŸ¥ã”ã¨ã«å‰²ã‚ŠæŒ¯ã‚‰ã‚Œã‚‹ ID
	NotificationID latest = -1;

	// ç”»åƒã‚’ä½œæˆãƒ»ä¿å­˜
	Emoji::CreateImage(U"ğŸ•").save(U"pizza.png");

	while (System::Update())
	{
		ClearPrint();

		// é€šçŸ¥ã®çŠ¶æ…‹
		Print << (int32)Platform::Windows::ToastNotification::GetState(latest);

		// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®çµæœ
		Print << U"Action: " << Platform::Windows::ToastNotification::GetAction(latest);

		if (SimpleGUI::Button(U"Send a notification", Vec2(10, 70)))
		{
			ToastNotificationProperty toast{
				.title = U"Title", // é€šçŸ¥ã®ã‚¿ã‚¤ãƒˆãƒ«
				.message = U"Message", // é€šçŸ¥ã®æœ¬æ–‡
				.imagePath = U"pizza.png", // å¤§ãã„ç”»åƒã ã¨ä½¿ã‚ã‚Œãªã„ã“ã¨ãŒã‚ã‚‹
				.actions = { U"Yes", U"No" } // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ï¼ˆä¸è¦ãªå ´åˆã¯è¨­å®šã—ãªã„ï¼‰
			};

			// é€šçŸ¥ã”ã¨ã«å‰²ã‚ŠæŒ¯ã‚‰ã‚Œã‚‹ ID ã‚’å–å¾—
			latest = Platform::Windows::ToastNotification::Show(toast);
		}
	}
}
```


## 10. SimpleGUIManager
TOML ãƒ•ã‚¡ã‚¤ãƒ«ã« SimpleGUI ã®å„ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’è¨˜è¿°ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚å®Ÿè¡Œä¸­ã«æ“ä½œã—ãŸå€¤ã‚’ä¿å­˜ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

![](images/042-10.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	// SimpleGUI ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆæƒ…å ±ã‚’è¨˜è¿°ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«
	const FilePath tomlPath = FileSystem::FullPath(U"example/gui/gui.toml");
	
	// æ›´æ–°ã‚’æ¤œçŸ¥
	const DirectoryWatcher watcher(FileSystem::ParentPath(tomlPath));
	
	// GUI ã‚’ãƒ­ãƒ¼ãƒ‰
	SimpleGUIManager gui(tomlPath);

	while (System::Update())
	{
		// TOML ãŒæ›´æ–°ã•ã‚ŒãŸã‚‰ GUI ã‚’å†ãƒ­ãƒ¼ãƒ‰
		for (const auto& change : watcher.retrieveChanges())
		{
			if (change.first == tomlPath && change.second == FileAction::Modified)
			{
				ClearPrint();
				gui.load(tomlPath);
			}
		}

		// GUI ã‚’æ›´æ–°ãƒ»æç”»
		gui.draw();

		if (gui.button(U"bt-OK")) // "bt-OK" ã¨ã„ã†åå‰ã®ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸ
		{
			Print << U"OK";
		}
		else if (gui.button(U"bt-Cancel")) // "bt-Cancel" ã¨ã„ã†åå‰ã®ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸ
		{
			Print << U"Cancel";
		}

		Scene::SetBackground(gui.colorPicker(U"cp-Color")); // "cp-Color ã¨ã„ã†åå‰ã®ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®å€¤ 
	}

	// ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆæƒ…å ±ã¨å€¤ã‚’ save.toml ã¨ã„ã†åå‰ã§ä¿å­˜ã™ã‚‹
	// ã“ã‚Œã‚’ SimpleGUIManager ã§èª­ã¿è¾¼ã¾ã›ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
	//gui.save(U"save.toml");
}
```


## 11. Print ã®æ’ä»–åˆ¶å¾¡
ãƒ‡ãƒãƒƒã‚°ãªã©ã®ç”¨é€”ã®ãŸã‚ã«ã€`Print` ã‚’è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰åŒæ™‚ã«å‘¼ã³å‡ºã—å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚

![](images/042-11.png)

```C++
// Siv3D ã®ä¸¦åˆ—å‡¦ç†é–¢æ•°ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹ãƒã‚¯ãƒ­
// ãƒ˜ãƒƒãƒ€ãŒå¢—ãˆã‚‹ãŸã‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ãŒå°‘ã—é•·ããªã‚‹
# define SIV3D_CONCURRENT
# include <Siv3D.hpp>

void Main()
{
	// 0ï½15 ã®æ•°ã«å¯¾ã—ã¦ã€è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†
	Range(0, 15).parallel_each([](int32 i)
	{
		// ã‚¹ãƒ¬ãƒƒãƒ‰è­˜åˆ¥å­ã‚’åˆã‚ã›ã¦è¡¨ç¤º
		Print << U"{}: {}"_fmt(std::this_thread::get_id(), i);
	});

	while (System::Update())
	{

	}
}
```


## 12. 3D å½¢çŠ¶
`Quaternion`, `OBB` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚`Ray` ã¨å„ç¨® 3D å½¢çŠ¶ã¨ã®äº¤å·®åˆ¤å®šã‚‚ã„ãã¤ã‹è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚

ãŸã ã— v0.4.1 ã¨åŒæ§˜ã€2D æç”»ã§ 3D ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ç°¡æ˜“çš„ãªã‚‚ã®ãªã®ã§ã€æ¬¡ã®ã‚ˆã†ãªåˆ¶ç´„ãŒã‚ã‚Šã¾ã™ã€‚

- æ·±åº¦ãƒãƒƒãƒ•ã‚¡ãŒç„¡ã„ã®ã§å‰å¾Œåˆ¤å®šãŒã§ããªã„
- é è¿‘ã‚¯ãƒªãƒƒãƒ—ãŒç„¡ã„ã®ã§ã‚«ãƒ¡ãƒ©ã«è¿‘ã™ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œãªã„

![](images/042-12.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(0, 0, 0);
	Vec3 eyePosition(0, 10, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	Array<OBB> objects;

	for (auto x : Range(-2, 2))
	{
		for (auto z : Range(2, -2, -1))
		{
			objects << OBB(Vec3(x * 4, 1, z * 4), Vec3(3, 2, 0.5), Quaternion::RollPitchYaw(0, x * 30_deg, 0));
			objects << OBB(Vec3(x * 4, 5, z * 4), Vec3(2, 1, 2), Quaternion::RollPitchYaw(x * 30_deg, 0, 0));
		}
	}

	while (System::Update())
	{
		eyePosition = Cylindrical(20, Scene::Time() * 30_deg, 8 + Periodic::Sine0_1(4s) * 8);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto i : Range(-10, 10))
			{
				Line3D(Vec3(-10, 0, i), Vec3(10, 0, i)).draw(mat, ColorF(0.5));
				Line3D(Vec3(i, 0, -10), Vec3(i, 0, 10)).draw(mat, ColorF(0.5));
			}

			const Vec3 eyePos = camera.getEyePosition();
			const Vec3 rayEnd = camera.screenToWorldPoint(Cursor::Pos(), 0.5f);
			const Ray cursorRay(eyePos, (rayEnd - eyePos).normalized());

			objects.sort_by([&](const OBB& a, const OBB& b)
			{
				return (eyePos.distanceFromSq(a.center)) > (eyePos.distanceFromSq(b.center));
			});

			Optional<size_t> intersectionIndex;

			for (auto [i, object] : IndexedReversed(objects))
			{
				if (cursorRay.intersects(object))
				{
					intersectionIndex = i;
					Cursor::RequestStyle(CursorStyle::Hand);
					break;
				}
			}

			for (auto [i, object] : Indexed(objects))
			{
				const HSV color((object.center.x * 50 + object.center.z * 10), 1.0, (i == intersectionIndex) ? 1.0 : 0.3);
				object.draw(mat, color);
			}
		}
	}
}
```

### v0.4.1 ã‚µãƒ³ãƒ—ãƒ«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
`AABB`, `Triangle3D`, `Line3D` ãªã©ãŒã€`s3d::experimental` åå‰ç©ºé–“ã‹ã‚‰ `s3d` åå‰ç©ºé–“ã«ç§»å‹•ã—ã¾ã—ãŸã€‚

#### 3D Triangles

![](images/041-17.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	constexpr std::array<Vec3, 8> vertices =
	{
		Vec3(-1, 1, -1),
		Vec3(1, 1, -1),
		Vec3(-1, -1, -1),
		Vec3(1, -1, -1),
		Vec3(1, 1, 1),
		Vec3(-1, 1, 1),
		Vec3(1, -1, 1),
		Vec3(-1, -1, 1),
	};

	constexpr std::array<uint32, 36> indices =
	{
		0, 1, 2, 2, 1, 3,
		5, 4, 0, 0, 4, 1,
		1, 4, 3, 3, 4, 6,
		5, 0, 7, 7, 0, 2,
		4, 5, 6, 6, 5, 7,
		2, 3, 7, 7, 3, 6,
	};

	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(0, 0, 0);
	Vec3 eyePosition(0, 4, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(8, Scene::Time() * 30_deg, Math::Sin(Scene::Time()) * 4);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto i : step(12))
			{
				const Vec3 p0(vertices[indices[i * 3 + 0]]);
				const Vec3 p1(vertices[indices[i * 3 + 1]]);
				const Vec3 p2(vertices[indices[i * 3 + 2]]);

				Triangle3D(p0, p1, p2).draw(mat, HSV(i * 30));
			}
		}
	}
}
```

#### 3D AABB

![](images/041-18.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(0, 0, 0);
	Vec3 eyePosition(0, 10, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(20, Scene::Time() * 30_deg, 8 + Periodic::Sine0_1(4s) * 8);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto i : Range(-10, 10))
			{
				Line3D(Vec3(-10, 0, i), Vec3(10, 0, i)).draw(mat, ColorF(0.5));
				Line3D(Vec3(i, 0, -10), Vec3(i, 0, 10)).draw(mat, ColorF(0.5));
			}

			AABB(Vec3(0, 1, 0), Vec3(2, 2, 2)).draw(mat, Palette::White);
			AABB(Vec3(-8, 1, 8), Vec3(2, 2, 2)).draw(mat, HSV(0));
			AABB(Vec3(8, 1, 8), Vec3(2, 2, 2)).draw(mat, HSV(90));
			AABB(Vec3(8, 1, -8), Vec3(2, 2, 2)).draw(mat, HSV(270));
			AABB(Vec3(-8, 1, -8), Vec3(2, 2, 2)).draw(mat, HSV(180));
		}
	}
}
```

#### 3D Terrain

![](images/041-19.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	Window::Resize(1280, 720);
	Scene::SetBackground(ColorF(0.05, 0.3, 0.7));

	RenderTexture rt(100, 100, ColorF(0.0), TextureFormat::R32_Float);
	Grid<float> heightMap;
	Grid<Float3> positions;

	constexpr double fov = 45_deg;
	constexpr Vec3 focusPosition(50, 0, -50);
	Vec3 eyePosition(0, 100, 0);
	experimental::BasicCamera3D camera(Scene::Size(), fov, eyePosition, focusPosition);

	while (System::Update())
	{
		eyePosition = Cylindrical(Arg::r = 80, Arg::phi = Scene::Time() * 30_deg, Arg::y = 50) + Vec3(50, 0, -50);
		camera.setView(eyePosition, focusPosition);
		const Mat4x4 mat = camera.getMat4x4();

		rt.read(heightMap);
		{
			positions.resize(heightMap.size());

			for (auto p : step(heightMap.size()))
			{
				positions[p] = Float3(p.x, heightMap[p], -p.y);
			}
		}

		{
			ScopedRenderTarget2D target(rt);
			ScopedRenderStates2D blend(BlendState::Additive);

			if (MouseL.pressed())
			{
				Circle(Cursor::Pos(), 8).draw(ColorF(Scene::DeltaTime() * 24.0));
			}
		}

		if (positions)
		{
			ScopedRenderStates2D culling(RasterizerState::SolidCullBack);

			for (auto x : step(positions.width() - 1))
			{
				for (auto y : step(positions.height()))
				{
					const Float3 begin = positions[{x, y}];
					const Float3 end = positions[{x + 1, y}];
					const ColorF color = HSV(120 - (begin.y + end.y) * 3, 0.75, 0.7);
					Line3D(begin, end).draw(mat, color);
				}
			}

			for (auto x : step(positions.width()))
			{
				for (auto y : step(positions.height() - 1))
				{
					const Float3 begin = positions[{x, y}];
					const Float3 end = positions[{x, y + 1}];
					const ColorF color = HSV(120 - (begin.y + end.y) * 3, 0.75, 0.7);
					Line3D(begin, end).draw(mat, color);
				}
			}
		}

		rt.draw(ColorF(0.1));
	}
}
```


## 13. Microphone ä¸å…·åˆä¿®æ­£
macOS ãªã©ä¸€éƒ¨ã®ç’°å¢ƒã§ãƒã‚¤ã‚¯ãŒä½¿ãˆãªã‹ã£ãŸä¸å…·åˆã‚’ä¿®æ­£ã—ã¾ã—ãŸã€‚

![](images/042-13.png)

```C++
# include <Siv3D.hpp>

void Main()
{
	// ãƒã‚¤ã‚¯ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
	Microphone mic(unspecified); // unspecified ã‚’æŒ‡å®šã™ã‚‹ã¨æ—¢å®šã®éŸ³å£°å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ

	if (!mic)
	{
		// ãƒã‚¤ã‚¯ã‚’åˆ©ç”¨ã§ããªã„å ´åˆã€çµ‚äº†
		throw Error(U"Microphone not available");
	}

	// éŒ²éŸ³ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆ
	mic.start();

	LineString points(800);

	FFTResult fft;

	while (System::Update())
	{
		// æ³¢å½¢ã‚’å¯è¦–åŒ–
		{
			const size_t pos = mic.posSample();
			const Array<WaveSampleS16>& buffer = mic.getBuffer();
			const size_t bufferLength = buffer.size();

			for (size_t i = 0; i < points.size(); ++i)
			{
				const size_t bufferPos = (pos + bufferLength - (800 - i)) % bufferLength;
				const double value = buffer[bufferPos].left / 32768.0;
				points[i].set(i, 300 - value * 300);
			}

			points.draw(2);
		}

		// å‘¨æ³¢æ•°ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ã‚’å–å¾—
		mic.fft(fft);

		// å‘¨æ³¢æ•°ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ çµæœã‚’å¯è¦–åŒ–
		for (auto i : step(800))
		{
			const double size = Pow(fft.buffer[i], 0.6f) * 1200;
			RectF(Arg::bottomLeft(i, 600), 1, size).draw(HSV(240 - i));
		}

		// å‘¨æ³¢æ•°ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ä¸Šã«å‘¨æ³¢æ•°ã‚’è¡¨ç¤º
		Rect(Cursor::Pos().x, 0, 1, Scene::Height()).draw();
		ClearPrint();
		Print << U"{} Hz"_fmt(Cursor::Pos().x * fft.resolution);
	}
}
```


## 14. QRDecoder ä¸å…·åˆä¿®æ­£
è¤‡æ•°ã® QR ã‚³ãƒ¼ãƒ‰ã®æ¤œå‡ºã®ä¸å…·åˆã‚’ä¿®æ­£ã—ã¾ã—ãŸã€‚

```C++
# include <Siv3D.hpp>

void Main()
{
	Window::Resize(1280, 720);

	// Web ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•
	Webcam webcam(0);
	webcam.setResolution(1280, 720);
	if (!webcam.start())
	{
		throw Error(U"");
	}

	Image image;
	DynamicTexture texture;
	QRDecoder qrDecoder;
	Array<std::pair<Quad, bool>> quads;

	while (System::Update())
	{
		// æ–°ã—ã„æ’®å½±ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
		if (webcam.hasNewFrame())
		{
			webcam.getFrame(image);

			Array<QRContent> qrs;

			// QR ã‚³ãƒ¼ãƒ‰ã‚’æ¤œå‡º
			qrDecoder.decode(image, qrs);

			quads.clear();

			for (const auto& qr : qrs)
			{
				quads.emplace_back(qr.quad, qr.isValid());

				// ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ãŸå ´åˆãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º
				if (qr.isValid())
				{
					Print << qr.text;
				}
			}

			texture.fill(image);
		}

		texture.draw();

		// QR ã‚³ãƒ¼ãƒ‰ã®é ˜åŸŸã‚’è¡¨ç¤º
		// ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ãŸå ´åˆèµ¤è‰²
		for (const auto& quad : quads)
		{
			quad.first.drawFrame(6, quad.second ? Palette::Red : Palette::Gray);
		}
	}
}
```


## 15. RenderTexture, MSRenderTexture æ”¹å–„
`RenderTexture` ã‚„ `MSRenderTexture` ã® `.clear()`, `.read()`, `.resolve()` ãŒ const ãƒ¡ãƒ³ãƒé–¢æ•°ã«ä¿®æ­£ã•ã‚Œã€ä½¿ã„ã‚„ã™ããªã‚Šã¾ã—ãŸã€‚  
ï¼ˆã‚µãƒ³ãƒ—ãƒ«çœç•¥ï¼‰
